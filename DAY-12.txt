5
public class linked {
// Define the node class
static class Node {
int data;
Node next;
// Constructor to initialize a node
Node(int data) {
this.data = data;
this.next = null;
}
}
// Head of the linked list
private Node head;
6
// Constructor to initialize an empty list
public linked() {
head = null;
}
// Function to insert a node at the beginning
public void insertAtBegin(int data) {
// Create a new node
Node newNode = new Node(data);
// Link the new node to the current head
newNode.next = head;
// Update the head to point to the new node
head = newNode;
}
// Function to display the linked list
public void displayList() {
Node temp = this.head;
System.out.print("Linked list: ");
while (temp != null) {
System.out.print(temp.data + " -> ");
temp = temp.next;
}
System.out.println("NULL");
}
// Main method to test the linked list
public static void main(String[] args) {
// Create a new linked list instance
linked l = new linked();
// Insert nodes at the beginning
l.insertAtBegin(10);
l.insertAtBegin(20);
l.insertAtBegin(30);
// Display the linked list
l.displayList();
}
}
Output:
7
Linked list: 30 -> 20 -> 10 -> NULL
//Method to insert a node at the end
public void insertAtEnd(int data) {
Node newNode = new Node(data);
// If the list is empty, make the new node as head
if (head == null) {
head = newNode;
return;
}
// Traverse to the last node
Node temp = head;
while (temp.next != null) {
temp = temp.next;
}
// Link the new node to the last node
temp.next = newNode;
}
// Method to insert a node at a specific position
public void insertAtPos(int data, int position) {
// If position is 0, insert at the beginning
if (position == 0) {
newNode.next = head;
head = newNode;
return;
}
Node newNode = new Node(data);
Node temp = head;
// Traverse to the position before where we want to insert
for (int i = 0; i < position - 1 && temp != null; i++) {
temp = temp.next;
}
// If position is beyond the list length
if (temp == null) {
8
System.out.println("Position out of bounds. Inserting at the end.");
insertAtEnd(data);
return;
}
// Insert the new node
newNode.next = temp.next;
temp.next = newNode;
}
// Function to delete the first node
public void deleteAtBegin() {
if (head == null) {
System.out.println("List is empty");
return;
}
Node temp = head; // Store the current head
head = temp.next; // Update the head to the next node
System.out.println("Deleted " + temp.data + " from beginning");
// Note: In Java, garbage collection automatically handles memory cleanup
// No need to manually free memory like in C
}
// Method to delete the last node
public void deleteAtEnd() {
if (head == null) {
System.out.println("List is empty");
return;
}
// If there's only one node
if (head.next == null) {
System.out.println("Deleted " + head.data + " from end");
head = null;
return;
}
// Traverse to the second last node
Node temp = head;
while (temp.next.next != null) {
temp = temp.next;
9
}
System.out.println("Deleted " + temp.next.data + " from end");
temp.next = null; // Remove the last node
}
//Method to delete a node at specific position (0-indexed)
public void deleteAtPosition(int position) {
if (head == null) {
System.out.println("List is empty");
return;
}
Node temp = head;
// Traverse to the node before the position to be deleted
for (int i = 0; i < position - 1 && temp != null; i++) {
temp = temp.next;
}
// If position is beyond the list length
if (temp == null || temp.next == null) {
System.out.println("Position out of bounds");
return;
}
Node nodeToDelete = temp.next;
temp.next = nodeToDelete.next;
System.out.println("Deleted " + nodeToDelete.data + " from position " + position);
}